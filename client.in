#!/bin/sh
#
# $Log: client.in,v $
# Revision 1.15  2022-06-28 19:32:22+05:30  Cprogrammer
# display MDrive mounted once
#
# Revision 1.14  2022-06-28 14:01:32+05:30  Cprogrammer
# updated for mac
#
# Revision 1.13  2022-04-30 11:11:04+05:30  Cprogrammer
# unmount MDrive
#
# Revision 1.12  2021-09-29 19:38:31+05:30  Cprogrammer
# removed hardcoded MPD host name
#
# Revision 1.11  2021-09-24 11:40:13+05:30  Cprogrammer
# added cmd line arg to umount
#
# Revision 1.10  2021-04-13 16:50:16+05:30  Cprogrammer
# removed call to mpd_backup
#
# Revision 1.9  2021-01-11 22:20:51+05:30  Cprogrammer
# do backup
#
# Revision 1.8  2020-08-31 16:40:53+05:30  Cprogrammer
# redo logic for killing background commands
#
# Revision 1.7  2020-08-31 12:21:31+05:30  Cprogrammer
# fixed signal name for bourne shell
#
# Revision 1.6  2020-08-29 17:12:27+05:30  Cprogrammer
# kill cat always
#
# Revision 1.5  2020-08-29 16:00:49+05:30  Cprogrammer
# use signal names compatible with Bourne Shell
#
# Revision 1.4  2020-08-29 12:09:36+05:30  Cprogrammer
# handle case when started as a session leader
#
# Revision 1.3  2020-08-28 22:19:26+05:30  Cprogrammer
# set trap after mpd, automount service startup
#
# Revision 1.2  2020-08-28 22:05:32+05:30  Cprogrammer
# terminate cat on svc -d
#
# Revision 1.1  2020-08-28 17:19:32+05:30  Cprogrammer
# Initial revision
#
#
# $Id: client.in,v 1.15 2022-06-28 19:32:22+05:30 Cprogrammer Exp mbhangui $
#

suicide()
{
    if [ -n "$CAT_PID" ] ; then
        kill $CAT_PID 2>/dev/null
    fi
    echo "ARGH!!! Committing suicide. Going down on SIGTERM"
    exit 1
}

do_umount()
{
    while true
    do
        echo "Stopping mpd.service"
		if [ -x /usr/bin/systemctl ] ; then
        	systemctl stop mpd.service 
		elif [ -d $servicedir/mpd ] ; then
			svc -d $servicedir/mpd
		else
			break
		fi
        if [ $? -eq 0 ] ; then
            break
        fi
    done
    # MDrive on RPI has the directory sounds
    if [ -d /var/lib/mpd/MDrive/sounds ] ; then
        echo "Unmounting MDrive"
        count=1
        while true
        do
            umount /var/lib/mpd/MDrive
            if [ $? -eq 0 -o $count -eq 60 ] ; then
                break
            fi
            drive_mounted=$(df -k |grep MDrive)
            if [ -z "$drive_mounted" ] ; then
              break
            fi
            count=`expr $count + 1`
            sleep 1
        done
    fi
	if [ -x /usr/bin/systemctl ] ; then
    	while true
    	do
        	echo "Stopping autofs.service"
        	systemctl stop autofs.service 
        	if [ $? -eq 0 ] ; then
            	break
        	fi
    	done
	fi
}

trap suicide TERM INT
servicedir=@servicedir@

if [ "$1" = "sleep" ] ; then
    sleep 20
elif [ "$1" = "umount" ] ; then
    do_umount
else
    mpd_up=0
    autofs_up=0
    count=1
    mpd_was_down=0
    autofs_was_down=0
	mdrive_mounted=0
    while true
    do
		# 1. we assume we are running on Linux mostly
		# 2. If on mac/freebsd, we assume autofs has been setup
		if [ -x /usr/bin/systemctl ] ; then
        	systemctl status autofs.service >/dev/null 2>&1
        	if [ $? -ne 0 ] ; then
            	autofs_was_down=1
            	echo "starting automount filesystems"
            	systemctl start autofs.service
            	sleep 1
            	continue
        	else
            	autofs_up=1
            	if [ $autofs_was_down -eq 1 ] ; then
                	echo "started automount filesystems"
                	autofs_was_down=0
            	fi
        	fi
		fi
        if [ ! -f /var/lib/mpd/MDrive/data/stats.db ] ; then
            echo "MDrive not yet mounted"
            sleep 1
            continue
        fi
		if [ $mdrive_mounted -eq 0 ] ; then
			mdrive_mounted=1
        	echo "MDrive mounted"
		fi
		if [ -x /usr/bin/systemctl ] ; then
        	systemctl status mpd.service >/dev/null 2>&1
        	if [ $? -ne 0 ] ; then
            	# trigger autofs to mount MDrive
            	mpd_was_down=1
            	echo "starting music player daemon"
            	systemctl start mpd.service
        	else
            	mpd_up=1
            	if [ $mpd_was_down -eq 1 ] ; then
                	echo "started music player daemon"
                	mpd_was_down=0
            	fi
        	fi
        	[ $mpd_up -eq 1 ] && [ $autofs_up -eq 1 ] && break
		else
			svstat $servicedir/mpd >/dev/null 2>&1
        	if [ $? -ne 0 ] ; then
            	# trigger autofs to mount MDrive
            	mpd_was_down=1
            	echo "starting music player daemon"
				svc -u $servicedir/mpd
        	else
            	mpd_up=1
            	if [ $mpd_was_down -eq 1 ] ; then
                	echo "started music player daemon"
                	mpd_was_down=0
            	fi
        	fi
        	[ $mpd_up -eq 1 ] && break
		fi
        if [ $count -eq 60 ] ; then
            echo "Giving up..."
            svc -dx /service/fclient
            systemctl stop autofs
            umount /var/lib/mpd/MDrive
            break
        fi
        sleep 20
        count=`expr $count + 1`
    done
    if [ -x /var/lib/mpd/MDrive/bin/boot_sound ] ; then
        /var/lib/mpd/MDrive/bin/boot_sound >/dev/null 2>&1
    fi
    if [ -d /var/lib/mpd/MDrive/backup ] ; then
        @libexecdir@/pistop/backup
    fi
    echo "Waiting for poweroff"
    echo wait 1>&7
    sessions=`ps --no-headers -s $$`
    status=0
    if [ -x /usr/bin/setsid -a -n "$sessions" ] ; then
        /bin/cat <&6
    else
        /bin/cat <&6 &
        CAT_PID=$!
        # close file descriptor using <&- notation
        exec 6<&-
        wait $CAT_PID
        if [ $? -gt 128 ] ; then
            status=1
            kill $CAT_PID 2>/dev/null
        fi
    fi
    if [ $status -eq 0 ] ; then
        echo "Remote MPD Powered off [$POWER_OFF]"
        if [ -n "$POWER_OFF" ] ; then
            /sbin/poweroff
        else
            do_umount
        fi
    else
        echo "shutting down fclient service"
    fi
fi
